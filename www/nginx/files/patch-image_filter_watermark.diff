--- src/http/modules/ngx_http_image_filter_module.c
+++ src/http/modules/ngx_http_image_filter_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * watermark patch: Vadym Zakovinko <vp.zakovinko at gmail.com> updated by
  */
 
 
@@ -18,6 +19,7 @@
 #define NGX_HTTP_IMAGE_RESIZE    3
 #define NGX_HTTP_IMAGE_CROP      4
 #define NGX_HTTP_IMAGE_ROTATE    5
+#define NGX_HTTP_IMAGE_WATERMARK 6
 
 
 #define NGX_HTTP_IMAGE_START     0
@@ -45,6 +47,8 @@ typedef struct {
     ngx_uint_t                   sharpen;
 
     ngx_flag_t                   transparency;
+    ngx_str_t                    watermark;
+    ngx_str_t                    watermark_position;
 
     ngx_http_complex_value_t    *wcv;
     ngx_http_complex_value_t    *hcv;
@@ -150,6 +154,20 @@ static ngx_command_t  ngx_http_image_filter_commands[] = {
       offsetof(ngx_http_image_filter_conf_t, buffer_size),
       NULL },
 
+    { ngx_string("image_filter_watermark"),
+     NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_image_filter_conf_t, watermark),
+      NULL },
+
+    { ngx_string("image_filter_watermark_position"),
+     NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_image_filter_conf_t, watermark_position),
+      NULL },
+
       ngx_null_command
 };
 
@@ -518,6 +536,13 @@ ngx_http_image_process(ngx_http_request_t *r)
         return ngx_http_image_resize(r, ctx);
     }
 
+    if (conf->filter == NGX_HTTP_IMAGE_WATERMARK) {
+        if (!conf->watermark.data) {
+            return NULL;
+        }
+        return ngx_http_image_resize(r, ctx);
+    }
+
     ctx->max_width = ngx_http_image_filter_get_value(r, conf->wcv, conf->width);
     if (ctx->max_width == 0) {
         return NULL;
@@ -813,6 +838,9 @@ transparent:
 
         resize = 0;
 
+    } else if (conf->filter == NGX_HTTP_IMAGE_WATERMARK) {
+        resize = 0;
+
     } else { /* NGX_HTTP_IMAGE_CROP */
 
         resize = 0;
@@ -958,6 +986,40 @@ transparent:
         gdImageColorTransparent(dst, gdImageColorExact(dst, red, green, blue));
     }
 
+    if (conf->filter == NGX_HTTP_IMAGE_WATERMARK && conf->watermark.data) {
+        FILE *watermark_file = fopen((const char *)conf->watermark.data,"r");
+        if (watermark_file) {
+            gdImagePtr watermark, watermark_mix;
+            ngx_int_t wdx = 0, wdy = 0;
+
+            watermark = gdImageCreateFromPng(watermark_file);
+
+            if(watermark != NULL) {
+              watermark_mix = gdImageCreateTrueColor(watermark->sx, watermark->sy);
+              if (ngx_strcmp(conf->watermark_position.data,
+                           "bottom-right") == 0) {
+                wdx = dx - watermark->sx - 10;
+                wdy = dy - watermark->sy - 10;
+              } else if (ngx_strcmp(conf->watermark_position.data, "top-left") == 0) {
+                wdx = wdy = 10;
+              } else if (ngx_strcmp(conf->watermark_position.data, "top-right") == 0) {
+                wdx = dx - watermark->sx - 10;
+                wdy = 10;
+              } else if (ngx_strcmp(conf->watermark_position.data, "bottom-left") == 0) {
+                wdx = 10;
+                wdy = dy - watermark->sy - 10;
+              }
+              gdImageCopy(watermark_mix, dst, 0, 0, wdx, wdy, watermark->sx, watermark->sy);
+              gdImageCopy(watermark_mix, watermark, 0, 0, 0, 0, watermark->sx, watermark->sy);
+              gdImageCopyMerge(dst, watermark_mix, wdx, wdy, 0, 0, watermark->sx, watermark->sy, 75);
+              gdFree(watermark);
+              gdFree(watermark_mix);
+            } else { ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "watermark file '%s' is not PNG", conf->watermark.data);}
+        } else {
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "watermark file '%s' not found", conf->watermark.data);
+        }
+    }
+
     sharpen = ngx_http_image_filter_get_value(r, conf->shcv, conf->sharpen);
     if (sharpen > 0) {
         gdImageSharpen(dst, sharpen);
@@ -1237,6 +1299,11 @@ ngx_http_image_filter_merge_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                               1 * 1024 * 1024);
 
+    ngx_conf_merge_str_value(conf->watermark, prev->watermark, "");
+
+    ngx_conf_merge_str_value(conf->watermark_position,
+                             prev->watermark_position, "bottom-right");
+
     return NGX_CONF_OK;
 }
 
@@ -1266,6 +1333,9 @@ ngx_http_image_filter(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         } else if (ngx_strcmp(value[i].data, "size") == 0) {
             imcf->filter = NGX_HTTP_IMAGE_SIZE;
 
+        } else if (ngx_strcmp(value[i].data, "watermark") == 0) {
+            imcf->filter = NGX_HTTP_IMAGE_WATERMARK;
+
         } else {
             goto failed;
         }
